match([Child|Siblings], Expr) :-
    match(Child, Expr)
    ; match(Siblings, Expr).
match(Node, Expr) :-
    Node = Expr
    ; (Node = element(_, Children), match(Children, Expr)).
match(Expr) :-
    match({prolog_ast}, Expr).

visit(Rewriter, [], ResultExpr) :-
    ResultExpr = [].
visit(Rewriter, [Child|Siblings], ResultExpr) :-
    visit(Rewriter, Child, ChildExpr),
    visit(Rewriter, Siblings, SiblingExpr),
    append([ChildExpr], [SiblingExpr], ResultExpr).
visit(Rewriter, Expr, ResultExpr) :-
    (rewrite(Rewriter, Expr, NewExpr), visit(Rewriter, NewExpr, ResultExpr), !)
    ; (Expr = element(Tag, Children), visit(Rewriter, Children, ChildrenExpr), ResultExpr = element(Tag, ChildrenExpr)).

visitAST(Rewriter, ResultExpr) :-
    visit(Rewriter, {prolog_ast}, ResultExpr).

% Provide a dynamic predicate such as:
customRewrite(Expr, NewExpr) :-
    Expr = element(div, Children),
    NewExpr = element(p, Children).

% Example of applying a rule via call -- make a 'helloVisit' declaration that is wrapped with this
rewrite(Rule, Expr, NewExpr) :-
    call(Rule, Expr, NewExpr).

% Need to specify what the possibilities are
% TODO: Generate this from document? Other options?
% (Obviously can declare as facts, etc)
tag(Tag) :-
    Tag = '{{tags[0]}}'
    {%- for tag in tags[1:-1] %}
    ; Tag = '{{tag}}'
    {%- endfor %}
    ; Tag = '{{tags[-1]}}'.

% HTML AST
element(Tag, []) :-
    tag(Tag).
element(Tag, [Child|Siblings]) :-
    tag(Tag),
    Child = element(ChildTag, ChildChildren),
    element(ChildTag, ChildChildren),
    element(Tag, Siblings).

formatElement([], '').
formatElement([E|Es], Output) :-
    formatElement(E, EOut),
    formatElement(Es, EsOut),
    format(atom(Output), '~a~a', [EOut, EsOut]).
formatElement(Element, Output) :-
    Element = element(Tag, Children),
    formatElement(Children, ChildOut),
    format(atom(Output), '<~a>~a</~a>', [Tag, ChildOut, Tag]).
